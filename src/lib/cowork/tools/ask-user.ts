/**
 * AskUserQuestion Tool
 * Allows the agent to ask the user multi-choice questions
 */

import type { ToolExecutor } from "./types";
import { storePendingQuestion } from "../question-store";

export const askUserQuestionTool: ToolExecutor = {
  name: "AskUserQuestion",
  description:
    "Ask the user a multi-choice question to clarify requirements or get input. Use this when you need user input before proceeding. The question will be displayed as an interactive card in the chat, and the agent will wait for the user's response.",
  parameters: {
    type: "object",
    additionalProperties: false,
    properties: {
      prompt: {
        type: "string",
        description: "The question text to display to the user",
      },
      options: {
        type: "array",
        items: {
          type: "object",
          additionalProperties: false,
          properties: {
            id: { type: "string", description: "Option ID" },
            label: {
              type: "string",
              description: "Option label displayed to user",
            },
          },
          required: ["id", "label"],
        },
        description: "List of answer options (must have at least 2 options)",
      },
      allowMultiple: {
        type: "boolean",
        description:
          "Whether the user can select multiple options (default: false)",
        default: false,
      },
      questionId: {
        type: "string",
        description:
          "Optional question ID (generated by system if not provided)",
      },
    },
    required: ["prompt", "options"],
  },
  permissionLevel: "auto",
  async execute(input, context) {
    const {
      prompt,
      options,
      allowMultiple,
      questionId: providedQuestionId,
    } = input as {
      prompt: string;
      options: Array<{ id: string; label: string }>;
      allowMultiple?: boolean;
      questionId?: string;
    };

    if (!prompt || typeof prompt !== "string") {
      return {
        content: "Error: prompt must be a non-empty string",
        isError: true,
      };
    }

    if (!Array.isArray(options) || options.length < 2) {
      return {
        content: "Error: options must be an array with at least 2 options",
        isError: true,
      };
    }

    // Validate options structure
    for (const opt of options) {
      if (!opt.id || !opt.label) {
        return {
          content: "Error: each option must have both 'id' and 'label' fields",
          isError: true,
        };
      }
    }

    // Use provided question ID or generate one
    const questionId =
      providedQuestionId ||
      `question_${Date.now()}_${Math.random().toString(36).substring(7)}`;

    // Store pending question and wait for answer
    try {
      const answers = await storePendingQuestion(questionId, {
        id: questionId,
        prompt,
        options: options.map((opt) => ({
          id: opt.id,
          label: opt.label,
        })),
        allowMultiple: allowMultiple || false,
      });

      // Format answer as text for the agent
      const answerText = Object.entries(answers)
        .map(([questionId, answer]) => {
          const option = options.find((opt) => opt.id === questionId);
          return option
            ? `${option.label}: ${answer}`
            : `${questionId}: ${answer}`;
        })
        .join(", ");

      return {
        content: `User answered: ${answerText}`,
        isError: false,
        metadata: {
          questionId,
          answers,
        },
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return {
        content: `Question was ${message.includes("timeout") ? "timed out" : "cancelled"}. No answer received.`,
        isError: true,
        metadata: { questionId, error: message },
      };
    }
  },
};
